//! TypeScript API client code generation
//!
//! Generates a self-contained `api-client.ts` file from project introspection data.
//! The generated file uses native `fetch()` with no external dependencies.

use crate::codegen::introspect::{EntityMeta, LinkMeta, ProjectIntrospection};
use crate::utils::naming;

// ── Public API ────────────────────────────────────────────────────────

/// Generate a complete TypeScript API client file from project introspection.
pub fn generate(project: &ProjectIntrospection) -> String {
    let mut out = String::new();

    // Header
    out.push_str(&generate_header());
    out.push('\n');

    // Helper function
    out.push_str(&generate_fetch_helper());
    out.push('\n');

    // Interfaces + CRUD for each entity
    for entity in &project.entities {
        out.push_str(&generate_entity_section(entity));
        out.push('\n');
    }

    // Link functions
    if !project.links.is_empty() {
        out.push_str("// ── Link functions ────────────────────────────────────────────────\n\n");
        for link in &project.links {
            out.push_str(&generate_link_function(link, &project.entities));
        }
    }

    out
}

// ── Type mapping ──────────────────────────────────────────────────────

/// Convert a Rust type string to its TypeScript equivalent.
pub fn rust_type_to_ts(rust_type: &str) -> String {
    let trimmed = rust_type.trim();

    // Handle Option<T> → T | null
    if let Some(inner) = strip_wrapper(trimmed, "Option<", ">") {
        return format!("{} | null", rust_type_to_ts(inner));
    }

    // Handle Vec<T> → T[]
    if let Some(inner) = strip_wrapper(trimmed, "Vec<", ">") {
        let inner_ts = rust_type_to_ts(inner);
        // Wrap union types in parens for array: (T | null)[]
        if inner_ts.contains(" | ") {
            return format!("({})[]", inner_ts);
        }
        return format!("{}[]", inner_ts);
    }

    // Handle HashMap<K, V> → Record<K, V>
    if let Some(inner) = strip_wrapper(trimmed, "HashMap<", ">")
        && let Some((k, v)) = split_generic_pair(inner)
    {
        return format!("Record<{}, {}>", rust_type_to_ts(k), rust_type_to_ts(v));
    }

    // Primitive mappings
    match trimmed {
        "String" | "&str" | "Uuid" | "uuid::Uuid" => "string".to_string(),
        "f32" | "f64" | "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64"
        | "u128" | "isize" | "usize" => "number".to_string(),
        "bool" => "boolean".to_string(),
        "DateTime<Utc>" | "chrono::DateTime<Utc>" | "NaiveDateTime" => "string".to_string(), // ISO 8601
        "Value" | "serde_json::Value" | "JsonValue" => "unknown".to_string(),
        _ => trimmed.to_string(), // Pass through unknown types as-is
    }
}

/// Strip a wrapper type, e.g. `strip_wrapper("Option<String>", "Option<", ">")` → Some("String")
fn strip_wrapper<'a>(s: &'a str, prefix: &str, suffix: &str) -> Option<&'a str> {
    if s.starts_with(prefix) && s.ends_with(suffix) {
        Some(&s[prefix.len()..s.len() - suffix.len()])
    } else {
        None
    }
}

/// Split `K, V` inside a generic, respecting nested angle brackets.
fn split_generic_pair(s: &str) -> Option<(&str, &str)> {
    let mut depth = 0;
    for (i, c) in s.char_indices() {
        match c {
            '<' => depth += 1,
            '>' => depth -= 1,
            ',' if depth == 0 => {
                return Some((s[..i].trim(), s[i + 1..].trim()));
            }
            _ => {}
        }
    }
    None
}

// ── Code generation sections ──────────────────────────────────────────

fn generate_header() -> String {
    r#"// Auto-generated by `this generate client` — do not edit manually.
// Re-run `this generate client` to regenerate after adding entities or links.

const API_BASE = import.meta.env.VITE_API_URL || '';
"#
    .to_string()
}

fn generate_fetch_helper() -> String {
    r#"async function fetchJson<T>(path: string, options?: RequestInit): Promise<T> {
  const res = await fetch(`${API_BASE}${path}`, {
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    ...options,
  });
  if (!res.ok) {
    throw new Error(`API error ${res.status}: ${res.statusText}`);
  }
  if (res.status === 204) return undefined as unknown as T;
  return res.json();
}
"#
    .to_string()
}

fn generate_entity_section(entity: &EntityMeta) -> String {
    let mut out = String::new();
    let pascal = &entity.pascal_name;

    out.push_str(&format!(
        "// ── {} ────────────────────────────────────────────────\n\n",
        pascal
    ));

    // Main interface
    out.push_str(&generate_interface(
        pascal,
        &entity.fields,
        InterfaceKind::Full,
    ));
    out.push('\n');

    // Create interface (without id, created_at, updated_at)
    out.push_str(&generate_interface(
        &format!("Create{}", pascal),
        &entity.fields,
        InterfaceKind::Create,
    ));
    out.push('\n');

    // Update interface (all optional)
    out.push_str(&generate_interface(
        &format!("Update{}", pascal),
        &entity.fields,
        InterfaceKind::Update,
    ));
    out.push('\n');

    // CRUD functions
    out.push_str(&generate_crud_functions(entity));

    out
}

#[derive(PartialEq)]
enum InterfaceKind {
    Full,
    Create,
    Update,
}

/// Fields to exclude from Create interfaces (auto-generated by the backend)
const AUTO_FIELDS: &[&str] = &["id", "created_at", "updated_at"];

fn generate_interface(
    name: &str,
    fields: &[crate::codegen::introspect::FieldMeta],
    kind: InterfaceKind,
) -> String {
    let mut out = format!("export interface {} {{\n", name);

    if kind == InterfaceKind::Full {
        // Always include id for the full entity
        out.push_str("  id: string;\n");
    }

    for field in fields {
        if kind == InterfaceKind::Create && AUTO_FIELDS.contains(&field.name.as_str()) {
            continue;
        }

        let ts_type = rust_type_to_ts(&field.rust_type);
        let optional = if kind == InterfaceKind::Update {
            "?"
        } else {
            ""
        };
        out.push_str(&format!("  {}{}: {};\n", field.name, optional, ts_type));
    }

    if kind == InterfaceKind::Full {
        // Add timestamp fields
        out.push_str("  created_at: string;\n");
        out.push_str("  updated_at: string;\n");
    }

    out.push_str("}\n");
    out
}

fn generate_crud_functions(entity: &EntityMeta) -> String {
    let pascal = &entity.pascal_name;
    let plural = &entity.plural;
    let snake = &entity.snake_name;

    let fn_list = naming::to_pascal_case(plural);
    let fn_single = naming::to_pascal_case(snake);

    format!(
        r#"export async function list{fn_list}(): Promise<{pascal}[]> {{
  return fetchJson<{pascal}[]>('/api/{plural}');
}}

export async function get{fn_single}(id: string): Promise<{pascal}> {{
  return fetchJson<{pascal}>(`/api/{plural}/${{id}}`);
}}

export async function create{fn_single}(data: Create{pascal}): Promise<{pascal}> {{
  return fetchJson<{pascal}>('/api/{plural}', {{
    method: 'POST',
    body: JSON.stringify(data),
  }});
}}

export async function update{fn_single}(id: string, data: Update{pascal}): Promise<{pascal}> {{
  return fetchJson<{pascal}>(`/api/{plural}/${{id}}`, {{
    method: 'PUT',
    body: JSON.stringify(data),
  }});
}}

export async function delete{fn_single}(id: string): Promise<void> {{
  return fetchJson<void>(`/api/{plural}/${{id}}`, {{
    method: 'DELETE',
  }});
}}
"#,
        fn_list = fn_list,
        fn_single = fn_single,
        pascal = pascal,
        plural = plural,
    )
}

fn generate_link_function(link: &LinkMeta, entities: &[EntityMeta]) -> String {
    let source_pascal = naming::to_pascal_case(&link.source);
    let source_plural = find_plural(&link.source, entities);
    let target_pascal = naming::to_pascal_case(&link.target);
    let forward_pascal = naming::to_pascal_case(&link.forward_route);

    format!(
        r#"export async function get{source_pascal}{forward_pascal}({source}Id: string): Promise<{target_pascal}[]> {{
  return fetchJson<{target_pascal}[]>(`/api/{source_plural}/${{{source}Id}}/{forward_route}`);
}}
"#,
        source_pascal = source_pascal,
        forward_pascal = forward_pascal,
        source = link.source,
        target_pascal = target_pascal,
        source_plural = source_plural,
        forward_route = link.forward_route,
    )
}

/// Find the plural form for an entity by snake_name, falling back to name + "s"
fn find_plural(snake_name: &str, entities: &[EntityMeta]) -> String {
    entities
        .iter()
        .find(|e| e.snake_name == snake_name)
        .map(|e| e.plural.clone())
        .unwrap_or_else(|| format!("{}s", snake_name))
}

// ── Tests ─────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::introspect::{EntityMeta, FieldMeta, LinkMeta, ProjectIntrospection};

    // ── Type mapping tests ────────────────────────────────────────

    #[test]
    fn test_rust_type_to_ts_primitives() {
        assert_eq!(rust_type_to_ts("String"), "string");
        assert_eq!(rust_type_to_ts("&str"), "string");
        assert_eq!(rust_type_to_ts("f64"), "number");
        assert_eq!(rust_type_to_ts("f32"), "number");
        assert_eq!(rust_type_to_ts("i32"), "number");
        assert_eq!(rust_type_to_ts("i64"), "number");
        assert_eq!(rust_type_to_ts("u32"), "number");
        assert_eq!(rust_type_to_ts("u64"), "number");
        assert_eq!(rust_type_to_ts("bool"), "boolean");
        assert_eq!(rust_type_to_ts("Uuid"), "string");
        assert_eq!(rust_type_to_ts("uuid::Uuid"), "string");
    }

    #[test]
    fn test_rust_type_to_ts_datetime() {
        assert_eq!(rust_type_to_ts("DateTime<Utc>"), "string");
        assert_eq!(rust_type_to_ts("chrono::DateTime<Utc>"), "string");
        assert_eq!(rust_type_to_ts("NaiveDateTime"), "string");
    }

    #[test]
    fn test_rust_type_to_ts_option() {
        assert_eq!(rust_type_to_ts("Option<String>"), "string | null");
        assert_eq!(rust_type_to_ts("Option<f64>"), "number | null");
        assert_eq!(rust_type_to_ts("Option<bool>"), "boolean | null");
    }

    #[test]
    fn test_rust_type_to_ts_vec() {
        assert_eq!(rust_type_to_ts("Vec<String>"), "string[]");
        assert_eq!(rust_type_to_ts("Vec<f64>"), "number[]");
        assert_eq!(rust_type_to_ts("Vec<Option<String>>"), "(string | null)[]");
    }

    #[test]
    fn test_rust_type_to_ts_hashmap() {
        assert_eq!(
            rust_type_to_ts("HashMap<String, f64>"),
            "Record<string, number>"
        );
    }

    #[test]
    fn test_rust_type_to_ts_json_value() {
        assert_eq!(rust_type_to_ts("Value"), "unknown");
        assert_eq!(rust_type_to_ts("serde_json::Value"), "unknown");
    }

    #[test]
    fn test_rust_type_to_ts_unknown_passthrough() {
        assert_eq!(rust_type_to_ts("MyCustomType"), "MyCustomType");
    }

    // ── Interface generation tests ────────────────────────────────

    fn make_product_entity() -> EntityMeta {
        EntityMeta {
            pascal_name: "Product".to_string(),
            snake_name: "product".to_string(),
            plural: "products".to_string(),
            indexed_fields: vec!["name".to_string()],
            fields: vec![
                FieldMeta {
                    name: "name".to_string(),
                    rust_type: "String".to_string(),
                },
                FieldMeta {
                    name: "price".to_string(),
                    rust_type: "f64".to_string(),
                },
                FieldMeta {
                    name: "description".to_string(),
                    rust_type: "Option<String>".to_string(),
                },
            ],
            routes: vec![],
        }
    }

    #[test]
    fn test_generate_interface_full() {
        let entity = make_product_entity();
        let iface = generate_interface("Product", &entity.fields, InterfaceKind::Full);
        assert!(iface.contains("export interface Product {"));
        assert!(iface.contains("  id: string;"));
        assert!(iface.contains("  name: string;"));
        assert!(iface.contains("  price: number;"));
        assert!(iface.contains("  description: string | null;"));
        assert!(iface.contains("  created_at: string;"));
        assert!(iface.contains("  updated_at: string;"));
    }

    #[test]
    fn test_generate_interface_create_excludes_auto_fields() {
        let fields = vec![
            FieldMeta {
                name: "id".to_string(),
                rust_type: "Uuid".to_string(),
            },
            FieldMeta {
                name: "name".to_string(),
                rust_type: "String".to_string(),
            },
            FieldMeta {
                name: "created_at".to_string(),
                rust_type: "DateTime<Utc>".to_string(),
            },
        ];
        let iface = generate_interface("CreateProduct", &fields, InterfaceKind::Create);
        assert!(iface.contains("  name: string;"));
        assert!(!iface.contains("  id:"));
        assert!(!iface.contains("  created_at:"));
    }

    #[test]
    fn test_generate_interface_update_all_optional() {
        let entity = make_product_entity();
        let iface = generate_interface("UpdateProduct", &entity.fields, InterfaceKind::Update);
        assert!(iface.contains("  name?: string;"));
        assert!(iface.contains("  price?: number;"));
        assert!(iface.contains("  description?: string | null;"));
        // Update should not have id, created_at, updated_at
        assert!(!iface.contains("  id:"));
        assert!(!iface.contains("  created_at:"));
    }

    // ── CRUD functions tests ──────────────────────────────────────

    #[test]
    fn test_generate_crud_functions() {
        let entity = make_product_entity();
        let crud = generate_crud_functions(&entity);

        assert!(crud.contains("export async function listProducts(): Promise<Product[]>"));
        assert!(crud.contains("fetchJson<Product[]>('/api/products')"));
        assert!(crud.contains("export async function getProduct(id: string): Promise<Product>"));
        assert!(crud.contains(
            "export async function createProduct(data: CreateProduct): Promise<Product>"
        ));
        assert!(crud.contains(
            "export async function updateProduct(id: string, data: UpdateProduct): Promise<Product>"
        ));
        assert!(crud.contains("export async function deleteProduct(id: string): Promise<void>"));
        assert!(crud.contains("method: 'POST'"));
        assert!(crud.contains("method: 'PUT'"));
        assert!(crud.contains("method: 'DELETE'"));
    }

    // ── Link function tests ───────────────────────────────────────

    #[test]
    fn test_generate_link_function() {
        let entities = vec![
            make_product_entity(),
            EntityMeta {
                pascal_name: "Review".to_string(),
                snake_name: "review".to_string(),
                plural: "reviews".to_string(),
                indexed_fields: vec![],
                fields: vec![],
                routes: vec![],
            },
        ];
        let link = LinkMeta {
            link_type: "has_review".to_string(),
            source: "product".to_string(),
            target: "review".to_string(),
            forward_route: "reviews".to_string(),
            reverse_route: "product".to_string(),
        };
        let func = generate_link_function(&link, &entities);
        assert!(func.contains(
            "export async function getProductReviews(productId: string): Promise<Review[]>"
        ));
        assert!(func.contains("fetchJson<Review[]>(`/api/products/${productId}/reviews`)"));
    }

    // ── Full generation test ──────────────────────────────────────

    #[test]
    fn test_generate_full_file() {
        let project = ProjectIntrospection {
            entities: vec![make_product_entity()],
            links: vec![LinkMeta {
                link_type: "has_review".to_string(),
                source: "product".to_string(),
                target: "review".to_string(),
                forward_route: "reviews".to_string(),
                reverse_route: "product".to_string(),
            }],
        };

        let output = generate(&project);

        // Header
        assert!(output.contains("// Auto-generated by `this generate client`"));
        assert!(output.contains("const API_BASE = import.meta.env.VITE_API_URL || '';"));

        // Helper
        assert!(output.contains("async function fetchJson<T>"));

        // Interfaces
        assert!(output.contains("export interface Product {"));
        assert!(output.contains("export interface CreateProduct {"));
        assert!(output.contains("export interface UpdateProduct {"));

        // CRUD
        assert!(output.contains("export async function listProducts"));
        assert!(output.contains("export async function getProduct"));
        assert!(output.contains("export async function createProduct"));
        assert!(output.contains("export async function updateProduct"));
        assert!(output.contains("export async function deleteProduct"));

        // Link
        assert!(output.contains("export async function getProductReviews"));
    }

    #[test]
    fn test_generate_no_links_section() {
        let project = ProjectIntrospection {
            entities: vec![make_product_entity()],
            links: vec![],
        };

        let output = generate(&project);
        assert!(!output.contains("Link functions"));
    }

    #[test]
    fn test_generate_multiple_entities() {
        let project = ProjectIntrospection {
            entities: vec![
                make_product_entity(),
                EntityMeta {
                    pascal_name: "Order".to_string(),
                    snake_name: "order".to_string(),
                    plural: "orders".to_string(),
                    indexed_fields: vec![],
                    fields: vec![FieldMeta {
                        name: "total".to_string(),
                        rust_type: "f64".to_string(),
                    }],
                    routes: vec![],
                },
            ],
            links: vec![],
        };

        let output = generate(&project);
        assert!(output.contains("export interface Product {"));
        assert!(output.contains("export interface Order {"));
        assert!(output.contains("export async function listProducts"));
        assert!(output.contains("export async function listOrders"));
    }
}
