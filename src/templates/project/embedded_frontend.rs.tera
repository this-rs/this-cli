use axum::{
    http::{header, StatusCode, Uri},
    response::{IntoResponse, Response},
};
use rust_embed::RustEmbed;
use std::borrow::Cow;

#[derive(RustEmbed)]
#[folder = "dist/"]
struct Assets;

/// Serve an embedded frontend asset, with SPA fallback to index.html.
pub async fn serve_embedded(uri: Uri) -> impl IntoResponse {
    let path = uri.path().trim_start_matches('/');

    // Try exact path first
    match Assets::get(path) {
        Some(content) => serve_file(path, content.data),
        None => {
            // SPA fallback: serve index.html for client-side routing
            match Assets::get("index.html") {
                Some(content) => serve_file("index.html", content.data),
                None => (
                    StatusCode::NOT_FOUND,
                    "index.html not found in embedded assets",
                )
                    .into_response(),
            }
        }
    }
}

/// Build a response with the correct Content-Type from a file path and its data.
fn serve_file(path: &str, data: Cow<'_, [u8]>) -> Response {
    let mime = mime_guess::from_path(path).first_or_octet_stream();
    (
        [(header::CONTENT_TYPE, mime.as_ref().to_string())],
        data.into_owned(),
    )
        .into_response()
}
